const int Pin_IN1 = 9 ;
const int Pin_IN2 = 10 ;


const int Pin_Channel_A = 2;
const int Pin_Channel_B = 3;

const int CPR = 448*6.25;
const int count_Mode = 4;

volatile long encoder_Count = 0;
volatile int last_Encoded = 0;

float angle = 0.0;
int channel_A_value = 0;
int channel_B_value = 0;

float kp = 5;
float ki = 2.5;
float kd = 1.25;

float integral = 0;
float prev_error = 0;
float prev_time = 0;

const float ref_Amplitude = 180.0; //Degrees
const float ref_Frequency =  0.4; //HZ
const float ref_PhaseShift = 0.0; //degrees
unsigned long lastPrintTime = 0;
const unsigned long plotInterval = 50;//10ms

void ISR_1X() {
  int b = digitalRead(Pin_Channel_B);
    if (b == LOW) {
    encoder_Count += 1; // CW (Clockwise)
  } 
    else if (b == HIGH) {
    encoder_Count -= 1; // CCW (Counter-Clockwise)
  }
}

void ISR_2X() {
  int b = digitalRead(Pin_Channel_B);
    if (digitalRead(Pin_Channel_A) == b) {
    encoder_Count -= 1; // A and B are same -> CCW
  } 
    else {
    encoder_Count += 1; // A and B are different -> CW
  }
}

void ISR_4X() {
  int MSB = digitalRead(Pin_Channel_A);
  int LSB = digitalRead(Pin_Channel_B);
  int encoded = (MSB << 1) | LSB;
  
  int sum = (last_Encoded << 2) | encoded; 

  
  if (sum == 0b0001 || sum == 0b0111 || sum == 0b1110 || sum == 0b1000) {
    encoder_Count--;
  } 

  else if (sum == 0b0010 || sum == 0b0100 || sum == 0b1101 || sum == 0b1011) {
    encoder_Count++;
  }
  
  last_Encoded = encoded;
}

void setup() {
  pinMode(Pin_IN1,OUTPUT);
  pinMode(Pin_IN2,OUTPUT);

  pinMode(Pin_Channel_A, INPUT);
  pinMode(Pin_Channel_B, INPUT);

  Serial.begin(115200);

  if (count_Mode == 1){
    attachInterrupt(digitalPinToInterrupt(Pin_Channel_A), ISR_1X, RISING);
  } 
  else if (count_Mode == 2) {
    attachInterrupt(digitalPinToInterrupt(Pin_Channel_A), ISR_2X, CHANGE); 
  } 
  else if (count_Mode == 4) {
    attachInterrupt(digitalPinToInterrupt(Pin_Channel_A), ISR_4X, CHANGE);
    attachInterrupt(digitalPinToInterrupt(Pin_Channel_B), ISR_4X, CHANGE);
  
    int MSB = digitalRead(Pin_Channel_A); 
    int LSB = digitalRead(Pin_Channel_B); 
    last_Encoded = (MSB << 1) | LSB;

  digitalWrite(Pin_IN1, HIGH);
  digitalWrite(Pin_IN2, LOW);
}
}
void loop() {
  unsigned long t_now = millis();
  channel_A_value = digitalRead(Pin_Channel_A);
  channel_B_value = digitalRead(Pin_Channel_B);

  float t_sec = t_now/1000.0;

  long count_snapshot;
  noInterrupts();
  count_snapshot = encoder_Count;
  interrupts();

  float reference = Generate_Sine_Waveform(t_sec, ref_Amplitude, ref_Frequency, ref_PhaseShift);
  float r = reference;

  angle =(360 * count_snapshot) / (CPR * count_Mode);
  float y = angle;

  float error = r - y; 
  unsigned long dt = t_now - prev_time;
  float Ts = dt;
  if (dt == 0) dt = 1; 


  float U_Kp = kp * error;


  float U_Kd = kd * (error - prev_error) / (dt / 1000.0);


  float U_Ki = ki * integral;


  float U_PID = U_Kp + U_Kd + U_Ki;



  float U_Sat = constrain(U_PID,-40,40);

  if (U_Sat == U_PID) {
  integral += error * (dt / 1000.0);
  }

  Drive_Motor(U_Sat);


  if (t_now - lastPrintTime >= plotInterval) {
    lastPrintTime += plotInterval;
    Serial.print(t_sec, 3); Serial.print(", ");
    Serial.print(reference, 2); Serial.print(", ");
    Serial.print(angle, 2); Serial.print(", ");
    Serial.println(U_Sat, 1);
  }

  prev_error = error;
  prev_time = t_now;

  delay(1);
  return;


  Serial.print("Main Control Loop, t = ");Serial.print(t_sec, 1);Serial.print(" s");
  Serial.print(", Chanel A = ");Serial.print(channel_A_value);
  Serial.print(", Chanel B = ");Serial.print(channel_B_value);
  Serial.print(", Angle = ");Serial.print(-angle);Serial.println(" deg");
  delay(1000);

}
void Drive_Motor(int pwmVal){
  pwmVal = constrain(pwmVal,-100,100);
    if (pwmVal > 0) { 
  digitalWrite(Pin_IN1, HIGH);
  digitalWrite(Pin_IN2, LOW);
  }
   else if (pwmVal < 0) { 
  digitalWrite(Pin_IN1, LOW);
  digitalWrite(Pin_IN2, HIGH);
  }
    else { 
  digitalWrite(Pin_IN1, LOW);
  digitalWrite(Pin_IN2, LOW);
  }
}

float Generate_Square_Waveform( float t, float Amax, float freq, float phase_shift_deg){
    
  float ref_output = 0;
  float T = 1.0 / freq;
  float phase_shift_time = (phase_shift_deg / 360.0) * T;
  
  // คำนวณเวลาที่ปรับเฟสแล้ว และวนลูปตามคาบ T
  float t_mod = fmod(t + phase_shift_time, T); 

  // สร้างสัญญาณคลื่นสี่เหลี่ยม
  if (t_mod < T / 2.0){
    ref_output = +Amax;
  }
  else {
    ref_output = -Amax;
  }
  
  return ref_output;
}

float Generate_Sine_Waveform(float t, float Amax, float freq, float phase_shift_deg) {
    
  float ref_output = 0;


  float phase_shift_rad = (phase_shift_deg / 360.0f) * 2.0f * M_PI;


  ref_output = Amax * sinf(2.0f * M_PI * freq * t + phase_shift_rad);

  return ref_output;
}
